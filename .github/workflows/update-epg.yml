name: Update EPG

on:
  schedule:
    - cron: '0 3 * * *' # Runs once a day at 3 AM
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-epg:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      - name: Install Python Dependencies
        run: pip install beautifulsoup4 requests python-dateutil
      - name: Generate EPG File
        shell: python
        run: |
          import os, json, requests
          from bs4 import BeautifulSoup
          from datetime import datetime, timedelta, timezone
          from dateutil.relativedelta import relativedelta

          HEADERS = {'User-Agent': 'Mozilla/5.0'}
          LEAGUE_SLUGS = [
              "premier-league", "championship", "league-one",
              "league-two", "fa-cup", "league-cup"
          ]

          def fetch_html(url):
              try:
                  print(f"Fetching HTML: {url}")
                  r = requests.get(url, headers=HEADERS)
                  r.raise_for_status()
                  return r.text
              except: return None

          def parse_fixtures_from_html(html_content, competition_name):
              if not html_content: return []
              soup = BeautifulSoup(html_content, 'html.parser')
              fixtures = []
              
              # Find all date headings on the page
              date_headers = soup.find_all('h2', class_=lambda c: c and 'GroupHeader' in c)
              
              for header in date_headers:
                  try:
                      date_str = header.get_text(strip=True)
                      # The list of fixtures is the next <ul> element after the date header
                      fixture_list = header.find_parent().find_next_sibling('ul')
                      if not fixture_list: continue

                      for item in fixture_list.find_all('li', attrs={'data-tipo-topic-id': True}):
                          home_span = item.select_one('div[class*="TeamHome"] span.visually-hidden')
                          away_span = item.select_one('div[class*="TeamAway"] span.visually-hidden')
                          time_el = item.find('time')

                          if home_span and away_span and time_el:
                              kick_off_time = time_el.get_text(strip=True)
                              # Clean up date string and combine with time
                              clean_date_str = date_str.replace('st','').replace('nd','').replace('rd','').replace('th','')
                              full_date_str = f"{clean_date_str} {datetime.now().year} {kick_off_time}"
                              
                              # Parse the combined date and time string
                              dt_obj = datetime.strptime(full_date_str, '%A %d %B %Y %H:%M')
                              
                              fixtures.append({
                                  'home_team': home_span.get_text(strip=True),
                                  'away_team': away_span.get_text(strip=True),
                                  'datetime_utc': dt_obj.isoformat() + 'Z',
                                  'competition': competition_name
                              })
                  except Exception as e:
                      print(f"‚ö†Ô∏è Error processing a fixture block: {e}")
                      continue
              return fixtures

          def main():
              all_fixtures, all_teams = [], set()
              today = datetime.now()
              next_month_date = today + relativedelta(months=1)

              for slug in LEAGUE_SLUGS:
                  competition_name = slug.replace('-', ' ').title()
                  print(f"\n--- Processing Fixtures for {competition_name} ---")
                  base_url = f"https://www.bbc.co.uk/sport/football/{slug}"
                  
                  # We only need to fetch the main fixtures page now
                  fixtures_url = f"{base_url}/scores-fixtures"
                  fixtures_html = fetch_html(fixtures_url)
                  all_fixtures.extend(parse_fixtures_from_html(fixtures_html, competition_name))
              
              unique_fixtures = [dict(t) for t in {tuple(d.items()) for d in all_fixtures}]
              for fix in unique_fixtures:
                  all_teams.add(fix['home_team'])
                  all_teams.add(fix['away_team'])
              
              print(f"\n‚úÖ Found {len(unique_fixtures)} total unique fixtures across all competitions.")

              # --- EPG Generation Logic ---
              now_utc = datetime.now(timezone.utc)
              future_limit = now_utc + timedelta(days=60)
              xml = '<?xml version="1.0" encoding="UTF-8"?>\n<tv>'
              team_fixtures = {team: [] for team in all_teams}
              for fix in unique_fixtures:
                  team_fixtures.setdefault(fix['home_team'], []).append(fix)
                  team_fixtures.setdefault(fix['away_team'], []).append(fix)

              for team_name in sorted(all_teams):
                  team_slug = ''.join(c for c in team_name.lower().replace('&', 'and').replace(' ', '-') if c.isalnum() or c == '-')
                  xml += f'\n  <channel id="{team_slug}.uk"><display-name lang="en">{team_name}</display-name></channel>'
                  
                  sorted_fixtures = sorted(team_fixtures.get(team_name, []), key=lambda x: x['datetime_utc'])
                  next_game_start = datetime.fromisoformat(sorted_fixtures[0]['datetime_utc'].replace('Z', '+00:00')) if sorted_fixtures else None
                  
                  stop_time = next_game_start if next_game_start else future_limit
                  if stop_time > now_utc:
                      start_str = now_utc.strftime('%Y%m%d%H%M%S %z')
                      stop_str = stop_time.strftime('%Y%m%d%H%M%S %z')
                      xml += f'\n  <programme start="{start_str}" stop="{stop_str}" channel="{team_slug}.uk"><title lang="en">No Game Scheduled</title></programme>'
                  
                  for fixture in sorted_fixtures:
                      home_team, away_team = fixture['home_team'], fixture['away_team']
                      is_home_game = team_name == home_team
                      opponent, venue = (away_team, "(H)") if is_home_game else (home_team, "(A)")
                      dt_start = datetime.fromisoformat(fixture['datetime_utc'].replace('Z', '+00:00'))
                      dt_stop = dt_start + timedelta(hours=2)
                      start_str, stop_str = dt_start.strftime('%Y%m%d%H%M%S %z'), dt_stop.strftime('%Y%m%d%H%M%S %z')
                      xml += f'\n  <programme start="{start_str}" stop="{stop_str}" channel="{team_slug}.uk"><title lang="en">vs. {opponent} {venue}</title><desc lang="en">{fixture.get("competition", "")}</desc><category lang="en">Sports</category></programme>'
              
              xml += '\n</tv>'
              with open('epg.xml', 'w', encoding='utf-8') as f: f.write(xml)
              print("‚úÖ EPG file generated successfully.")

          if __name__ == "__main__":
              main()
      - name: Commit and Push EPG
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add epg.xml
          if git diff --staged --quiet;
            then echo "üü¢ No changes to EPG.";
            else git commit -m "üóìÔ∏è Automated EPG update"; git push;
          fi
