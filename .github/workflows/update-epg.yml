name: Update EPG

on:
  schedule:
    - cron: '0 3 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-epg:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      - name: Install Python Dependencies
        run: pip install beautifulsoup4 requests python-dateutil
      - name: Generate EPG File
        shell: python
        run: |
          import os, json, requests
          from bs4 import BeautifulSoup
          from datetime import datetime, timedelta, timezone
          from dateutil.relativedelta import relativedelta
          from zoneinfo import ZoneInfo

          HEADERS = {'User-Agent': 'Mozilla/5.0'}
          LEAGUE_SLUGS = [
              "premier-league", "championship", "league-one",
              "league-two", "fa-cup", "league-cup"
          ]

          def fetch_html(url):
              try:
                  print(f"Fetching HTML: {url}")
                  r = requests.get(url, headers=HEADERS)
                  r.raise_for_status()
                  return r.text
              except: return None

          def parse_fixtures(html_content, competition_name):
              if not html_content: return []
              fixtures = []
              try:
                  soup = BeautifulSoup(html_content, 'html.parser')
                  script_tag = soup.find('script', string=lambda t: t and 'window.__INITIAL_DATA__' in t)
                  json_text = script_tag.string.split('window.__INITIAL_DATA__=')[1].split(';')[0]
                  data = json.loads(json.loads(json_text))
                  fixtures_key = next((k for k in data.get('data', {}) if 'sport-data-scores-fixtures' in k), None)
                  if fixtures_key:
                      for group in data['data'][fixtures_key].get('data', {}).get('eventGroups', []):
                          for s_group in group.get('secondaryGroups', []):
                              for event in s_group.get('events', []):
                                  if event.get('status') == 'PreEvent':
                                      fixtures.append({'home_team': event['home']['fullName'],'away_team': event['away']['fullName'],'datetime_utc': event['startDateTime'],'competition': competition_name})
              except Exception as e:
                  print(f"‚ö†Ô∏è Could not parse fixtures from a page: {e}")
              return fixtures

          def main():
              all_fixtures, all_teams = [], set()
              today = datetime.now()
              next_month_date = today + relativedelta(months=1)

              for slug in LEAGUE_SLUGS:
                  competition_name = slug.replace('-', ' ').title()
                  if competition_name == "Fa Cup": competition_name = "FA Cup"
                  if competition_name == "League Cup": competition_name = "EFL Cup"
                  
                  print(f"\n--- Processing Fixtures for {slug} ---")
                  base_url = f"https://www.bbc.co.uk/sport/football/{slug}"
                  for url in [f"{base_url}/scores-fixtures/{today.strftime('%Y-%m')}", f"{base_url}/scores-fixtures/{today.strftime('%Y-%m')}?filter=fixtures", f"{base_url}/scores-fixtures/{next_month_date.strftime('%Y-%m')}"]:
                      all_fixtures.extend(parse_fixtures(fetch_html(url), competition_name))
              
              unique_fixtures = [dict(t) for t in {tuple(d.items()) for d in all_fixtures}]
              for fix in unique_fixtures:
                  all_teams.add(fix['home_team'])
                  all_teams.add(fix['away_team'])
              
              print(f"\n‚úÖ Found {len(unique_fixtures)} total unique fixtures across all competitions.")

              now_utc = datetime.now(timezone.utc)
              uk_tz = ZoneInfo("Europe/London")
              now_local = now_utc.astimezone(uk_tz)
              future_limit = now_local + timedelta(days=60)
              xml = '<?xml version="1.0" encoding="UTF-8"?>\n<tv>'
              team_fixtures = {team: [] for team in all_teams}
              for fix in unique_fixtures:
                  team_fixtures.setdefault(fix['home_team'], []).append(fix)
                  team_fixtures.setdefault(fix['away_team'], []).append(fix)

              for team_name in sorted(all_teams):
                  team_slug = ''.join(c for c in team_name.lower().replace('&', 'and').replace(' ', '-') if c.isalnum() or c == '-')
                  xml += f'\n  <channel id="{team_slug}.uk"><display-name lang="en">{team_name}</display-name></channel>'
                  
                  sorted_fixtures = sorted(team_fixtures.get(team_name, []), key=lambda x: x['datetime_utc'])
                  last_event_end_time = now_local

                  for fixture in sorted_fixtures:
                      dt_start_utc = datetime.fromisoformat(fixture['datetime_utc'].replace('Z', '+00:00'))
                      dt_start_local = dt_start_utc.astimezone(uk_tz)
                      
                      # Create "No Game" block in the gap before this game
                      if dt_start_local > last_event_end_time:
                          start_str = last_event_end_time.strftime('%Y%m%d%H%M%S %z')
                          stop_str = dt_start_local.strftime('%Y%m%d%H%M%S %z')
                          xml += f'\n  <programme start="{start_str}" stop="{stop_str}" channel="{team_slug}.uk"><title lang="en">No Game Scheduled</title></programme>'

                      # Create the actual game programme
                      dt_stop_local = dt_start_local + timedelta(hours=2)
                      start_str, stop_str = dt_start_local.strftime('%Y%m%d%H%M%S %z'), dt_stop_local.strftime('%Y%m%d%H%M%S %z')
                      opponent = fixture['away_team'] if team_name == fixture['home_team'] else fixture['home_team']
                      venue = "(H)" if team_name == fixture['home_team'] else "(A)"
                      xml += f'\n  <programme start="{start_str}" stop="{stop_str}" channel="{team_slug}.uk"><title lang="en">vs. {opponent} {venue}</title><desc lang="en">{fixture.get("competition", "")}</desc><category lang="en">Sports</category></programme>'
                      
                      last_event_end_time = dt_stop_local
                  
                  # Create a final "No Game" block from the last game until the future limit
                  if last_event_end_time < future_limit:
                      start_str = last_event_end_time.strftime('%Y%m%d%H%M%S %z')
                      stop_str = future_limit.strftime('%Y%m%d%H%M%S %z')
                      xml += f'\n  <programme start="{start_str}" stop="{stop_str}" channel="{team_slug}.uk"><title lang="en">No Game Scheduled</title></programme>'
              
              xml += '\n</tv>'
              with open('epg.xml', 'w', encoding='utf-8') as f: f.write(xml)
              print("‚úÖ EPG file generated successfully.")

          if __name__ == "__main__":
              main()
      - name: Commit and Push EPG
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add epg.xml
          if git diff --staged --quiet;
            then echo "üü¢ No changes to EPG.";
            else git commit -m "üóìÔ∏è Automated EPG update"; git push;
          fi
