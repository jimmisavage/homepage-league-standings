name: Update data

on:
  schedule:
    - cron: '*/5 12-23 * * SAT,SUN'
    - cron: '*/5 19-23 * * MON-FRI'
    - cron: '0 2 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  scrape-standings:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      - name: Install Python Dependencies
        run: pip install beautifulsoup4 requests
      - name: Load Configuration Variables
        id: load_config
        run: |
          if [[ -f "./config.env" ]]; then
            source ./config.env
            echo "LEAGUE_SLUG=${LEAGUE_SLUG}" >> $GITHUB_ENV
            echo "TEAM_NAME=${TEAM_SLUG}" >> $GITHUB_ENV
            echo "LEAGUE_ID_NAME=${LEAGUE_NAME}" >> $GITHUB_ENV
            echo "SEASON=${CURRENT_SEASON}" >> $GITHUB_ENV
          else
            echo "‚ùå ERROR: config.env file not found."
            exit 1
          fi
      - name: Run Python Scraper
        env:
          LEAGUE_SLUG: ${{ env.LEAGUE_SLUG }}
          TEAM_NAME: ${{ env.TEAM_NAME }}
          LEAGUE_ID_NAME: ${{ env.LEAGUE_ID_NAME }}
        shell: python
        run: |
          import os, json, requests
          from bs4 import BeautifulSoup

          TEAM_NAME = os.environ.get('TEAM_NAME', '').replace('-', ' ')
          LEAGUE_SLUG = os.environ.get('LEAGUE_SLUG')
          LEAGUE_ID_NAME = os.environ.get('LEAGUE_ID_NAME')
          HEADERS = {'User-Agent': 'Mozilla/5.0'}

          def fetch_html(url):
              try:
                  response = requests.get(url, headers=HEADERS)
                  response.raise_for_status()
                  return response.text
              except: return None

          def parse_standings(html_content):
              if not html_content: return []
              soup = BeautifulSoup(html_content, 'html.parser')
              table = soup.find('table', {'data-testid': 'football-table'})
              if not table: return []
              standings_data = []
              tbody = table.find('tbody')
              if not tbody: return []
              for row in tbody.find_all('tr'):
                  cells = row.find_all(['th', 'td'])
                  if len(cells) < 10: continue
                  try:
                      team_name_span = cells[0].find('span', class_='visually-hidden')
                      team_name = team_name_span.get_text(strip=True) if team_name_span else "Unknown"
                      standings_data.append({
                          'rank': int(cells[0].find('span', class_=lambda c: c and 'Rank' in c).get_text(strip=True)),
                          'team': {'name': team_name, 'logo': cells[0].find('img')['src'] if cells[0].find('img') else ''},
                          'points': int(cells[8].get_text(strip=True)), 'goalsDiff': int(cells[7].get_text(strip=True)),
                          'form': "".join([div.get_text(strip=True) for div in cells[9].find_all('div', {'data-testid': 'letter-content'})]),
                          'all': {'played': int(cells[1].get_text(strip=True)),'win': int(cells[2].get_text(strip=True)),'draw': int(cells[3].get_text(strip=True)),'lose': int(cells[4].get_text(strip=True)),'goals': {'for': int(cells[5].get_text(strip=True)), 'against': int(cells[6].get_text(strip=True))}},
                          'highlight': True if TEAM_NAME and TEAM_NAME in team_name.lower() else False, 'nextUp': 'TBD'
                      })
                  except: continue
              return standings_data

          def parse_fixtures(html_content):
              if not html_content: return []
              soup = BeautifulSoup(html_content, 'html.parser')
              fixtures = []
              try:
                  script_tag = soup.find('script', string=lambda t: t and 'window.__INITIAL_DATA__' in t)
                  json_text = script_tag.string.split('window.__INITIAL_DATA__=')[1].split(';')[0]
                  data = json.loads(json.loads(json_text))
                  fixtures_key = next((k for k in data.get('data', {}) if 'sport-data-scores-fixtures' in k), None)
                  if fixtures_key:
                      for group in data['data'][fixtures_key].get('data', {}).get('eventGroups', []):
                          for s_group in group.get('secondaryGroups', []):
                              for event in s_group.get('events', []):
                                  if event.get('status') == 'PreEvent':
                                      fixtures.append({'home_team': event['home']['fullName'],'away_team': event['away']['fullName'],'datetime_utc': event['startDateTime']})
              except: pass
              return fixtures

          def main():
              base_url = f"https://www.bbc.co.uk/sport/football/{LEAGUE_SLUG}"
              standings = parse_standings(fetch_html(f"{base_url}/table"))
              all_fixtures = parse_fixtures(fetch_html(f"{base_url}/scores-fixtures"))
              
              next_up_map = {}
              for fix in sorted(all_fixtures, key=lambda x: x['datetime_utc']):
                  if fix['home_team'] not in next_up_map: next_up_map[fix['home_team']] = f"{fix['away_team']} (H)"
                  if fix['away_team'] not in next_up_map: next_up_map[fix['away_team']] = f"{fix['home_team']} (A)"

              for team in standings:
                  if team['team']['name'] in next_up_map:
                      team['nextUp'] = next_up_map[team['team']['name']]
              
              os.makedirs('data', exist_ok=True)
              with open('data/standings.json', 'w') as f:
                  json.dump({'response': [{'league': {'name': LEAGUE_ID_NAME, 'standings': [standings]}}]}, f, indent=4)
              print("üöÄ Scrape complete.")

          if __name__ == "__main__": main()
      - name: Commit and Push Standings
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add data/standings.json
          if git diff --staged --quiet; then
            echo "üü¢ No changes to standings."
          else
            git commit -m "üìä Automated standings update"
            git push
          fi
